// Generated by CoffeeScript 1.4.0
(function() {
  var Funclet, async, bind, each, loglet, map,
    __slice = [].slice;

  async = require('async');

  loglet = require('loglet');

  Funclet = (function() {

    Funclet.make = function() {
      return new Funclet();
    };

    function Funclet() {
      this.calls = [];
      this.onError = console.error;
      this;

    }

    Funclet.prototype.bind = function() {
      var args, proc;
      proc = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return this.then(function(next) {
        return proc.apply(null, __slice.call(args).concat([next]));
      });
    };

    Funclet.prototype.then = function(proc) {
      if (proc.length === 1) {
        this.calls.push(function(cb) {
          try {
            return proc(cb);
          } catch (e) {
            return cb(e);
          }
        });
      } else {
        this.calls.push(function(res, cb) {
          try {
            return proc(res, cb);
          } catch (e) {
            return cb(e);
          }
        });
      }
      return this;
    };

    Funclet.prototype.map = function(ary, proc) {
      return this.then(function(next) {
        return async.map(ary, proc, next);
      });
    };

    Funclet.prototype.each = function(ary, proc) {
      return this.then(function(next) {
        return async.each(ary, proc, next);
      });
    };

    Funclet.prototype["catch"] = function(onError) {
      this.onError = onError;
      return this;
    };

    Funclet.prototype.done = function(lastCB) {
      var helper, interim, self;
      if (lastCB == null) {
        lastCB = function() {};
      }
      self = this;
      interim = [];
      helper = function(call, next) {
        var cb;
        cb = function() {
          var err, res;
          err = arguments[0], res = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          loglet.debug('funclet.done.helper.cb', err, interim);
          if (err) {
            return next(err);
          } else {
            interim = res;
            return next(null);
          }
        };
        try {
          return call.apply(null, __slice.call(interim).concat([cb]));
        } catch (e) {
          return cb(e);
        }
      };
      async.eachSeries(this.calls, helper, function(err) {
        try {
          if (err) {
            return self.onError(err);
          } else {
            try {
              return lastCB.apply(null, interim);
            } catch (e2) {
              return self.onError(e2);
            }
          }
        } catch (e) {
          return self.onError(e);
        }
      });
      return this;
    };

    return Funclet;

  })();

  bind = function() {
    var args, func;
    func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return Funclet.make().then(function(next) {
      return func.apply(null, __slice.call(args).concat([next]));
    });
  };

  map = function(ary, proc) {
    return Funclet.make().map(ary, proc);
  };

  each = function(ary, proc) {
    return Funclet.make().each(ary, proc);
  };

  module.exports = {
    bind: bind,
    map: map,
    each: each
  };

}).call(this);
